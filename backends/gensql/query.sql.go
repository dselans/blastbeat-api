// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package gensql

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createGenre = `-- name: CreateGenre :one
INSERT INTO genres (
  id,
  name,
  slug
) VALUES (
  $1,
  $2,
  $3
)
RETURNING id, name, slug
`

type CreateGenreParams struct {
	ID   uuid.UUID
	Name string
	Slug string
}

func (q *Queries) CreateGenre(ctx context.Context, arg CreateGenreParams) (Genre, error) {
	row := q.db.QueryRowContext(ctx, createGenre, arg.ID, arg.Name, arg.Slug)
	var i Genre
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const createRelease = `-- name: CreateRelease :one
INSERT INTO releases (
  id,
  title,
  artist,
  album_art_url,
  release_date,
  label,
  label_url,
  follower_count,
  genres,
  country,
  external_links,
  spotify_url,
  youtube_url,
  bandcamp_url
) VALUES (
  $1,  -- id
  $2,  -- title
  $3,  -- artist
  $4,  -- album_art_url
  $5,  -- release_date
  $6,  -- label
  $7,  -- label_url
  $8,  -- follower_count
  $9,  -- genres (jsonb)
  $10, -- country
  $11, -- external_links (jsonb)
  $12, -- spotify_url
  $13, -- youtube_url
  $14  -- bandcamp_url
)
RETURNING id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
`

type CreateReleaseParams struct {
	ID            uuid.UUID
	Title         string
	Artist        string
	AlbumArtUrl   string
	ReleaseDate   time.Time
	Label         string
	LabelUrl      sql.NullString
	FollowerCount int32
	Genres        json.RawMessage
	Country       sql.NullString
	ExternalLinks json.RawMessage
	SpotifyUrl    sql.NullString
	YoutubeUrl    sql.NullString
	BandcampUrl   sql.NullString
}

func (q *Queries) CreateRelease(ctx context.Context, arg CreateReleaseParams) (Release, error) {
	row := q.db.QueryRowContext(ctx, createRelease,
		arg.ID,
		arg.Title,
		arg.Artist,
		arg.AlbumArtUrl,
		arg.ReleaseDate,
		arg.Label,
		arg.LabelUrl,
		arg.FollowerCount,
		arg.Genres,
		arg.Country,
		arg.ExternalLinks,
		arg.SpotifyUrl,
		arg.YoutubeUrl,
		arg.BandcampUrl,
	)
	var i Release
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Artist,
		&i.AlbumArtUrl,
		&i.ReleaseDate,
		&i.Label,
		&i.LabelUrl,
		&i.FollowerCount,
		&i.Genres,
		&i.Country,
		&i.ExternalLinks,
		&i.SpotifyUrl,
		&i.YoutubeUrl,
		&i.BandcampUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGenre = `-- name: DeleteGenre :exec
DELETE FROM genres
WHERE id = $1
`

func (q *Queries) DeleteGenre(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGenre, id)
	return err
}

const deleteRelease = `-- name: DeleteRelease :exec
DELETE FROM releases
WHERE id = $1
`

func (q *Queries) DeleteRelease(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRelease, id)
	return err
}

const getGenre = `-- name: GetGenre :one
SELECT id, name, slug
FROM genres
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetGenre(ctx context.Context, id uuid.UUID) (Genre, error) {
	row := q.db.QueryRowContext(ctx, getGenre, id)
	var i Genre
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const getGenreBySlug = `-- name: GetGenreBySlug :one
SELECT id, name, slug
FROM genres
WHERE slug = $1
LIMIT 1
`

func (q *Queries) GetGenreBySlug(ctx context.Context, slug string) (Genre, error) {
	row := q.db.QueryRowContext(ctx, getGenreBySlug, slug)
	var i Genre
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const getRelease = `-- name: GetRelease :one
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetRelease(ctx context.Context, id uuid.UUID) (Release, error) {
	row := q.db.QueryRowContext(ctx, getRelease, id)
	var i Release
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Artist,
		&i.AlbumArtUrl,
		&i.ReleaseDate,
		&i.Label,
		&i.LabelUrl,
		&i.FollowerCount,
		&i.Genres,
		&i.Country,
		&i.ExternalLinks,
		&i.SpotifyUrl,
		&i.YoutubeUrl,
		&i.BandcampUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listGenres = `-- name: ListGenres :many
SELECT id, name, slug
FROM genres
ORDER BY name
`

func (q *Queries) ListGenres(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.QueryContext(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleases = `-- name: ListReleases :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
ORDER BY release_date DESC, created_at DESC
`

func (q *Queries) ListReleases(ctx context.Context) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByArtist = `-- name: ListReleasesByArtist :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE artist LIKE '%' || $1 || '%'
ORDER BY release_date DESC, created_at DESC
`

func (q *Queries) ListReleasesByArtist(ctx context.Context, dollar_1 sql.NullString) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByArtist, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByDateRange = `-- name: ListReleasesByDateRange :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE release_date BETWEEN $1 AND $2
ORDER BY release_date DESC, created_at DESC
`

type ListReleasesByDateRangeParams struct {
	ReleaseDate   time.Time
	ReleaseDate_2 time.Time
}

func (q *Queries) ListReleasesByDateRange(ctx context.Context, arg ListReleasesByDateRangeParams) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByDateRange, arg.ReleaseDate, arg.ReleaseDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByExactDate = `-- name: ListReleasesByExactDate :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE release_date = $1
ORDER BY created_at DESC
`

func (q *Queries) ListReleasesByExactDate(ctx context.Context, releaseDate time.Time) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByExactDate, releaseDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByFollowerRange = `-- name: ListReleasesByFollowerRange :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE follower_count BETWEEN $1 AND $2
ORDER BY follower_count DESC, release_date DESC
`

type ListReleasesByFollowerRangeParams struct {
	FollowerCount   int32
	FollowerCount_2 int32
}

func (q *Queries) ListReleasesByFollowerRange(ctx context.Context, arg ListReleasesByFollowerRangeParams) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByFollowerRange, arg.FollowerCount, arg.FollowerCount_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByGenre = `-- name: ListReleasesByGenre :many
SELECT r.id, r.title, r.artist, r.album_art_url, r.release_date, r.label, r.label_url, r.follower_count, r.genres, r.country, r.external_links, r.spotify_url, r.youtube_url, r.bandcamp_url, r.created_at, r.updated_at
FROM releases AS r
WHERE EXISTS (
  SELECT 1
  FROM jsonb_array_elements_text(r.genres) AS genre
  WHERE LOWER(genre) = LOWER($1)
)
ORDER BY r.release_date DESC, r.created_at DESC
`

func (q *Queries) ListReleasesByGenre(ctx context.Context, lower string) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByGenre, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleasesByGenresAny = `-- name: ListReleasesByGenresAny :many
SELECT r.id, r.title, r.artist, r.album_art_url, r.release_date, r.label, r.label_url, r.follower_count, r.genres, r.country, r.external_links, r.spotify_url, r.youtube_url, r.bandcamp_url, r.created_at, r.updated_at
FROM releases r
WHERE EXISTS (
  SELECT 1
  FROM jsonb_array_elements_text(r.genres) g(genre)
  WHERE g.genre = ANY($1::text[])
)
ORDER BY r.release_date DESC, r.created_at DESC
`

func (q *Queries) ListReleasesByGenresAny(ctx context.Context, dollar_1 []string) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, listReleasesByGenresAny, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchReleases = `-- name: SearchReleases :many
SELECT id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
FROM releases
WHERE artist LIKE '%' || $1 || '%'
   OR title LIKE '%' || $1 || '%'
ORDER BY release_date DESC, created_at DESC
`

func (q *Queries) SearchReleases(ctx context.Context, dollar_1 sql.NullString) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, searchReleases, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.AlbumArtUrl,
			&i.ReleaseDate,
			&i.Label,
			&i.LabelUrl,
			&i.FollowerCount,
			&i.Genres,
			&i.Country,
			&i.ExternalLinks,
			&i.SpotifyUrl,
			&i.YoutubeUrl,
			&i.BandcampUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGenre = `-- name: UpdateGenre :one
UPDATE genres
SET
  name = $2,
  slug = $3
WHERE id = $1
RETURNING id, name, slug
`

type UpdateGenreParams struct {
	ID   uuid.UUID
	Name string
	Slug string
}

func (q *Queries) UpdateGenre(ctx context.Context, arg UpdateGenreParams) (Genre, error) {
	row := q.db.QueryRowContext(ctx, updateGenre, arg.ID, arg.Name, arg.Slug)
	var i Genre
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const updateRelease = `-- name: UpdateRelease :one
UPDATE releases
SET
  title = $2,
  artist = $3,
  album_art_url = $4,
  release_date = $5,
  label = $6,
  label_url = $7,
  follower_count = $8,
  genres = $9,
  country = $10,
  external_links = $11,
  spotify_url = $12,
  youtube_url = $13,
  bandcamp_url = $14,
  updated_at = now()
WHERE id = $1
RETURNING id, title, artist, album_art_url, release_date, label, label_url, follower_count, genres, country, external_links, spotify_url, youtube_url, bandcamp_url, created_at, updated_at
`

type UpdateReleaseParams struct {
	ID            uuid.UUID
	Title         string
	Artist        string
	AlbumArtUrl   string
	ReleaseDate   time.Time
	Label         string
	LabelUrl      sql.NullString
	FollowerCount int32
	Genres        json.RawMessage
	Country       sql.NullString
	ExternalLinks json.RawMessage
	SpotifyUrl    sql.NullString
	YoutubeUrl    sql.NullString
	BandcampUrl   sql.NullString
}

func (q *Queries) UpdateRelease(ctx context.Context, arg UpdateReleaseParams) (Release, error) {
	row := q.db.QueryRowContext(ctx, updateRelease,
		arg.ID,
		arg.Title,
		arg.Artist,
		arg.AlbumArtUrl,
		arg.ReleaseDate,
		arg.Label,
		arg.LabelUrl,
		arg.FollowerCount,
		arg.Genres,
		arg.Country,
		arg.ExternalLinks,
		arg.SpotifyUrl,
		arg.YoutubeUrl,
		arg.BandcampUrl,
	)
	var i Release
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Artist,
		&i.AlbumArtUrl,
		&i.ReleaseDate,
		&i.Label,
		&i.LabelUrl,
		&i.FollowerCount,
		&i.Genres,
		&i.Country,
		&i.ExternalLinks,
		&i.SpotifyUrl,
		&i.YoutubeUrl,
		&i.BandcampUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
